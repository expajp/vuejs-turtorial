# コンポーネントの基本

## 基本例
* コンポーネントは、名前付きで再利用可能なVueインスタンス
* 作成したコンポーネントは、Vueインスタンス内でカスタム要素として使うことができる
    * 今回はbutton-counterという要素を作成した
* コンポーネントは、再利用可能なVueインスタンスなので、Vueインスタンスとしての性質をもつ
    * data, computed, watch, methods, ライフサイクルフックなどを受け入れる
    * ただし、elなどルート固有のオプションは受け入れない

## コンポーネントの再利用
* 必要なだけなんども再利用できる
* それぞれ別々のインスタンスが生成される

### コンポーネントのdataは関数でなくてはいけない
* よく見ると、**dataが関数になっている**
    * 戻り値がdataオブジェクトの代わりになるようにする
* 普通にオブジェクトを戻り値にすると**エラーを吐く**
* このルールがない場合を再現すると、同一オブジェクトのデータを弄るので全部のデータが連動する

## コンポーネントの編成
* Webアプリケーションはコンポーネントのツリーとして表現できる
* コンポーネントにはグローバルとローカルの2種類ある
    * ローカルの詳細については語ってくれない
    * 抜けてない？

## プロパティを使用した子コンポーネントへのデータの受け渡し
* コンポーネントを作るのは良いが、データを受け渡さないと役に立たない
    * そこで**プロパティ**ですよ
* プロパティ（props）はコンポーネントに付与できるカスタム属性
    * propsオプションに渡した名前のプロパティをコンポーネントが受け取ることができる
* テンプレートのカスタム属性としてもデータを渡せる
    * これを利用して、**v-forでデータを順に受け渡して表示**ができる

## 単一のルート要素
* Vueは、すべてのコンポーネントに単一のルート要素を要求する
    * つまり、**Vueコンポーネントとなれるのは、1つのルート要素とその子要素だけ**
* そして、blog-postコンポーネントが含む情報が**タイトルだけなわけがない**
    * ルート要素を単一に保ちつつたくさんの情報を入れようとすると、最終的にはこうなる

```html
<blog-post
  v-for="post in posts"
  v-bind:key="post.id"
  v-bind:title="post.title"
  v-bind:content="post.content"
  v-bind:publishedAt="post.publishedAt"
  v-bind:comments="post.comments"
></blog-post>
```

* この状況は、**すべての情報を格納したオブジェクトを1つバインドする**ことで避けることができる

```html
<blog-post
  v-for="post in posts"
  v-bind:key="post.id"
  v-bind:post="post"
></blog-post>
```
```JavaScript
Vue.component('blog-post', {
  props: ['post'],
  template: `
    <div class="blog-post">
      <h3>{{ post.title }}</h3>
      <div v-html="post.content"></div>
    </div>
  `
})
```

* JavaScriptのテンプレート文字列を使用しているので、IEを想定する場合はBabel必須

## イベントとメッセージを親コンポーネントに送出する
* 親コンポーネントとやりとりすることがある
    * どういうことかというと、木構造の親にプロパティの値を投げる
    * コンポーネントのプロパティをページ全体に適用するなど
* これは「子から親に対してイベントを伝え、親のイベントリスナを発火させる」という形で行う
* イベントの射出はビルトインの`$emit`メソッドを使う
    * emitメソッドはv-onの引数に設定し、「このイベントが発火したら射出しますよ」という宣言の形になる
* というわけなんだが、なんかうまくいかないぞどうすんだこれ
    * どう組んでもシンタックスエラーになる
* **なぜなら、テンプレート構文はバッククォートの中に書かなくてはならないから**である
    * わざわざバッククォートにしてある理由もこれではっきりした

### イベントと値を送出する
* `$emit`の2番目のパラメータでイベントだけでなく値も送出できる
* 送出した値は`$event`でアクセスできる
* また、イベントハンドラがメソッドの場合（というかこっちの場合が多いでしょ）は最初の引数として認識される

### コンポーネントでv-modelを使う
* v-modelで動作するカスタムモデルを作ることができる
    * つまり、**入力に連動して値の変わるモデルを紐づけた独自モデル**を作ることができる
* inputは以下の条件を満たす必要がある
    * value属性をvalueプロパティにバインド
    * inputではinputイベントを送出
    * つまり、**コンポーネントで定義する場合はそういうinputをtemplateに含めなくてはいけない**
* ちなみに、コンポーネントを適用する場合は、valueにあたるプロパティの名前はvalueでなくてよい
    * 例えばコンポーネントで`prop: ['value']`と指定していたとしても、
        * `v-model="hoge"`
        * `data: { hoge: 'piyo' }`
    * とすれば、コンポーネントにhogeがバインドされる
