# カスタムイベント
* カスタムイベントはclickなどの組み込みイベントとは違う、独自定義のイベントのことを指す
* つまり、イベントで発火するコールバックのことではないので注意

## イベント名
* コンポーネントやプロパティと違い、イベント名の大文字小文字は自動的に変換されない
* 発火するイベント名とイベントリスナ名は全く一緒にする必要がある
* イベント名はJSの中でトークンとして解釈されることはないので、いつでもケバブケースにしておくべき

## v-modelを使ったコンポーネントのカスタマイズ
* 2.2.0からの追加
* v-modelはvalueをプロパティとし、inputをイベントとして使うのがデフォルト
    * ただ、チェックボックスやラジオボタンなどはvalue属性を別の目的で使うことがある
* コンポーネントにmodelオプションを設定することでこれを回避できる
    * modelオプションには、監視対象のオプションとイベントを記述できる

## コンポーネントにネイティブイベントをバインディング
* コンポーネントのルート要素が持っているネイティブイベントを監視したい場合がある
    * コンポーネントのルート要素は親要素ではなく、「コンポーネントのルート要素は単一」のときに出てきたやつ
    * `.native`修飾子をv-onでつけると監視できる
* しかし、普通にnative修飾子で監視すると、**ルート要素が変わってしまった場合**に存在しないイベントを指定してしまう
    * この問題を解決するユーティリティをVueは提供している：`$listeners`
    * `$listeners`はコンポーネントで使えるリスナオブジェクトをまとめて持っている
    * これによって、コンポーネントの子要素（＝ルートでない要素）にコンポーネントのすべてのイベントリスナを渡すことができる
    * 新しい算出プロパティを定義したほうが便利な場合が多い

## .sync修飾子
* 2.3.0から追加
    * 現行はいくつや？
* 双方向バインディングがプロパティに対して必要になる場合がある
    * しかし、コンポーネントからプロパティ＝親要素の値を無秩序に変更できるとメンテナンスに問題がでる
    * 兄弟コンポーネントが参照しているデータが突然変わってしまうから
        * 非同期に起こるDOM操作であるはずなのにそこにない、という状況はつらみを引き起こす
        * つまり、再現性が低いためテスタビリティが低い
    * この問題は、イベントを親コンポーネントに送らなくては変更不可、とすることで解決できる
        * 親コンポーネントがそれを受け取ってデータの整合性を保つようなコールバックを書くよう強制させるため
* 普通は、変更するプロパティ名を含めたイベントを定義するのがベターなプラクティス
* しかし、この処理はよく使うため、**.syncという修飾子で短く書くことができる**
    * カスタム要素の属性に`v-bind:title.sync="vm.title"`とすることで、更新するコールバックを書かなくて良い
* `v-bind.sync="vm"`とすることで複数プロパティに対して同時定義が可能

