# プロパティ

## プロパティの形式（キャメルケース vs. ケバブケース）
* HTMLの属性名は大文字小文字を区別しない
    * つまり、テンプレート内ではケバブケース一択になる
* 文字列テンプレートを利用していてもこの制限は適用されない

## プロパティの型
* ここまで、propsは文字列配列として扱ってきた
    * しかし、プロパティごとに型を指定したい
* `{ プロパティ名: ラッパーオブジェクト }`の形でpropsを指定できる
    * このとき、型が間違っていると警告が出る

## 静的あるいは動的なプロパティの受け渡し
* プロパティには静的な値やv-bindでのオブジェクトを渡せるが、本来は任意の型の値を渡せる
* 基本v-bindで渡せるが、**直接指定かつ文字列**の場合はv-bindはなし
* オブジェクトをそのまま渡すこともできる
    * その場合、ルートオブジェクトのdataに定義する

## 単方向のデータフロー
* すべてのプロパティは子プロパティと親プロパティの間に単方向のデータバインディングを形成する
    * 親を更新すると子に流れ落ちる
    * 逆に、子を更新しても親には流れていかない
* つまり、**子がうっかり親コンポーネントを変更することがない**
    * 親コンポーネントの更新を許すと、**まるでグローバル変数のように**値の処理の収集がつかなくなる
* 子コンポーネントから親のプロパティを変化させたい場合は2つの方法がある
    * プロパティを**初期値**として受け渡したい場合
        * もともとコンポーネントのプロパティはfunctionとしてしか受け渡せない
        * propsに定義しておけば渡せる、あとはコンポーネントの中で処理をする
    * プロパティを未加工の値として渡す
        * 算出プロパティを子コンポーネントに定義しておく
* なんでわざわざこんなことをするかというと、**プロパティが参照渡しだから**である
    * つまり、子でいじると親まで変化する

## プロパティのバリデーション
* コンポーネントは、プロパティに型を指定できる
    * さっきオブジェクトでの指定を勉強したが、もっと多様な指定ができる
* 配列で指定すると複数の方を許容
* `{ type: String, required: true }`で入力必須に
* `{ type: Number, default: 100 }`でデフォルト値を指定
* `{ type: Object, default: function(){ return { message: 'hoge' } } }`のように**オブジェクトの初期値は関数で**
    * 何故か。参照渡しだからである
* カスタマイズしたバリデーション関数をvalidatesオプションで指定可能
    * 返す値は`Boolean`
* これらは、すべてバリデーションに失敗すると**コンソールで警告**される

### 型の検査
* 次のうちのいずれか
    * String
    * Number
    * Boolean
    * Array
    * Object
    * Date
    * Function
    * Symbol
* また、typeプロパティは`typeof`によるアサーションを行う
    * コンストラクタ関数が指定されているオブジェクトは検査が可能


