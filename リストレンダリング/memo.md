# リストレンダリング

## v-forで配列に要素をマッピングする
* 配列に基づいてアイテムリストを描画できる
    * 形式は``item in items``
    * 大事な点。v-forは**ディレクティブ**である
* v-forブロック内では、親プロパティへの完全なアクセスを持っている
* 配列のインデックスを2つめの任意引数として持てる

## オブジェクトのv-for
* オブジェクトのプロパティにv-forで反復処理ができる
    * これは普通のJSにもある機能、のはず
* コールバックを指定するように、value, key, indexが引数に使える

## key
* v-forで描画されたリストを更新するとき、標準ではパッチを使う
    * アイテムの順序が変更されたとき、並び替えるのではなく描画を変更する
    * これは、描画されたリストが**子コンポーネントやDOMの状態に依存していない場合にのみ**有効
* 要素の再利用と並び替えのため、key属性を要素に与える必要がある
    * v-bind:keyを使って指定する必要がある
    * 省略を使って:keyとするのがよい
* v-forにkeyを与えると要素の再利用と並び替えが行える
    * 高速化を行う場合以外は、とりあえずv-forにはkeyをつけるべき
* keyは汎用的な仕組みなので、v-for以外に使うこともある
    * あとで出てくる

## 配列の変化を検出
### 変更メソッド
* Vueは画面の更新をトリガするため、配列オブジェクトの一部のメソッドをラップしている
    * つまり、拡張している
* ラップされているのは以下のメソッドたち
    * push()
    * pop()
    * shift()
    * unshift()
    * splice()
    * sort()
    * reverse()

### 配列の置き換え
* 配列オブジェクトのメソッドには、破壊的でなく戻り値として変更後の配列を返すものがある
    * 例えばfilter()
* このようなメソッドが使われた場合も、Vueは全体の再描画は行わず最小限に抑える

### 注意事項
* JSの制限で、Vueは以下の変更を検出できない
    * インデックスでアイテムを直接指定するとき
    * 配列の長さを変更するとき
* Vue.setかArray.prototye.spliceを使おう
    * 配列、インデックス、値の3つの引数を取る
    * ちなみにvm.\$setでもOK

## オブジェクトの変更検出の注意
* Vueはプロパティの追加や削除を検出できない
* 配列同様、Vue.setが使える
    * というか、Vue.setはこちらの機能が本流でしょう
    * 配列はおまけ
* Object#assignを使うときは、**両方のオブジェクトのプロパティをマージする**形で使う
    * つまり、vm/userProfileに値を追加するときはこういうこと

```javascript
vm.userProfile = Object.assign({}, vm.userProfile, {
  age: 27,
  favoriteColor: 'Vue Green'
})
```
